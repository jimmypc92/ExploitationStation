// ExploitationFoundation.cpp : Defines the exported functions for the DLL application.
//

#include "ExploitationFoundation.h"
#include <stdio.h>

#define BUF_SIZE 4096
#define STOP_READING -1
#define PROCESSING_ERROR -2

HANDLE pipe, serverThread;
char *readBuf;

char* menu = "What would you like to do?\n0: exit.\n";

DWORD WINAPI runServer(LPVOID lpParam);
DWORD writeToPipe(HANDLE hPipe, LPSTR data);
DWORD processInput(char* input);
DWORD cleanup(DWORD error);

__declspec(dllexport) int openInjectionServer(const char *name) {
	pipe = CreateNamedPipeA(name, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, 1, 0x16000, 0x16000, 0, NULL);

	if (pipe == INVALID_HANDLE_VALUE) {
		printf("Error creating named pipe.\n");
		return cleanup(GetLastError());
	}

	serverThread = CreateThread(NULL, 0x1000000, runServer, NULL, NULL, NULL);

	if (serverThread = NULL) {
		printf("Error creating server thread.\n");
		return cleanup(GetLastError());
	}

	return 0;
}

__declspec(dllexport) int closeInjectionServer(LPVOID startParam) {
	return cleanup(0);
}

DWORD WINAPI runServer(LPVOID lpParam) {

	if (pipe == NULL) {
		cleanup(0);
		return -1;
	}

	readBuf = (char*)malloc(sizeof(char) * BUF_SIZE);

	if (readBuf == NULL) {

		cleanup(0);
		return -1;
	}

	BOOL res;

	res = ConnectNamedPipe(pipe, NULL);

	if (res == 0 && GetLastError() != ERROR_PIPE_CONNECTED) {
		printf("Error connecting to named pipe.\n");
		return cleanup(GetLastError());
	}

	BOOL fSuccess = false;
	DWORD numRead, numWritten;

	DWORD commandResult = 0;
	while (commandResult != -1) {

		fSuccess = writeToPipe(pipe, menu);
		if (fSuccess) {
			writeToPipe(pipe, TERMINATE_SEQUENCE);
			return cleanup(fSuccess);
		}

		do {
			fSuccess = ReadFile(pipe, readBuf, 1024, &numRead, NULL);

			if (!fSuccess && GetLastError() != ERROR_MORE_DATA) {
				writeToPipe(pipe, TERMINATE_SEQUENCE);
				return cleanup(GetLastError());
			}

		} while (!fSuccess);

		commandResult = processInput(readBuf);

		if (commandResult == PROCESSING_ERROR) {
			writeToPipe(pipe, TERMINATE_SEQUENCE);
			cleanup(0);
			return commandResult;
		}
	}

	writeToPipe(pipe, TERMINATE_SEQUENCE);
	cleanup(0);
	return 0;
}

DWORD processInput(char* input) {

	if (!strcmp(input, "0")) {
		return STOP_READING;
	}

	return 0;
}

DWORD cleanup(DWORD error) {
	if (pipe != INVALID_HANDLE_VALUE) {

		if (!DisconnectNamedPipe(pipe)) {
			pipe = INVALID_HANDLE_VALUE;
			return cleanup(GetLastError());
		}

		CloseHandle(pipe);
		pipe = INVALID_HANDLE_VALUE;
	}

	if (readBuf != NULL) {
		free(readBuf);
		readBuf = NULL;
	}

	BOOL res;
	char *message;

	if (error != 0) {
		res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, NULL, (LPSTR)&message, 100, NULL);

		if (!res) {
			printf("Error getting formatted error message.\n");
		}
		else {
			printf("%s\n", message);
		}
	}

	return error;
}

//
// returns: 0 success
//
DWORD writeToPipe(HANDLE hPipe, LPSTR data) {
	DWORD fSuccess, res;
	fSuccess = WriteFile(pipe, data, strlen(data)+1, NULL, NULL); 

	if (!fSuccess) {
		printf("Writing to pipe failed.\n");
		return GetLastError();
	}

	res = FlushFileBuffers(pipe);

	if (!res) {
		printf("Flushing pipe buffer failed.");
		return GetLastError();
	}

	return 0;
}