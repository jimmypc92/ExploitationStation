// ExploitationFoundation.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"
#include <stdlib.h>
#include <stdio.h>

#define BUF_SIZE 4096

HANDLE pipe, serverThread;
char *readBuf;

char* menu = "What would you like to do?\n0: exit.\n";

DWORD WINAPI runServer(LPVOID lpParam);
int cleanup(DWORD error);

int openInjectionServer(const char *name) {
	pipe = CreateNamedPipeA(name, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_WAIT, 1, 0x16000, 0x16000, 0, NULL);

	if (pipe == INVALID_HANDLE_VALUE) {
		return cleanup(GetLastError());
	}

	serverThread = CreateThread(NULL, 0x1000000, runServer, NULL, NULL, NULL);

	if (serverThread = NULL) {
		return cleanup(GetLastError());
	}

	return 0;
}

DWORD WINAPI runServer(LPVOID lpParam) {

	if (pipe == NULL) {
		cleanup(0);
		return -1;
	}

	readBuf = (char*)malloc(sizeof(char) * BUF_SIZE);

	if (readBuf == NULL) {

		cleanup(0);
		return -1;
	}

	bool res;

	res = ConnectNamedPipe(pipe, NULL);

	if (res == 0 && GetLastError() != ERROR_PIPE_CONNECTED) {
		cleanup(GetLastError());
		return -1;
	}

	bool fSuccess = false;
	DWORD numRead, numWritten;
	while (true) {

		do {

			fSuccess = ReadFile(pipe, readBuf, 1024, &numRead, NULL);

			if (!fSuccess && GetLastError() != ERROR_MORE_DATA) {
				return cleanup(GetLastError());
			}

		} while (!fSuccess);

		WriteFile(pipe, menu, strlen(menu), &numWritten, NULL);

		res = FlushFileBuffers(pipe);

		if (!res) {
			cleanup(GetLastError());
			return -1;
		}

		break;
	}

	return 0;
}

int cleanup(DWORD error) {
	if (pipe != NULL) {
		CloseHandle(pipe);
		pipe = NULL;
	}

	if (readBuf != NULL) {
		free(readBuf);
		readBuf = NULL;
	}

	BOOL res;
	char *message;

	if (error != 0) {
		res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, NULL, (LPSTR)&message, 100, NULL);

		if (!res) {
			printf("%s\n", message);
			return GetLastError();
		}
	}

	return error;
}